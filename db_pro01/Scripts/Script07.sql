-- ORDER BY는 마지막에 실행
SELECT EMPLOYEE_ID 
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, SALARY
	, COMMISSION_PCT 
	, HIRE_DATE 
	FROM EMPLOYEES
 ORDER BY SALARY, NAME DESC; -- 급여 내림차순, 급여동일하면 이름 오름차순 
-- 별칭, 컬럼순서, 컬럼명 지정 가능
-- 기본은 오름차순(DESC 붙이면 내림차순)

 
SELECT EMPLOYEE_ID 
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, SALARY
	, COMMISSION_PCT 
	, HIRE_DATE 
	FROM EMPLOYEES
 ORDER BY NAME DESC;
 
-- NULLS FIRST : NULL 데이터 먼저 보이게 / NULLS LAST : NULL 맨 뒤로
SELECT EMPLOYEE_ID 
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, SALARY
	, COMMISSION_PCT 
	, HIRE_DATE 
	FROM EMPLOYEES
 ORDER BY 4 NULLS FIRST;
 
SELECT EMPLOYEE_ID 
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, SALARY
	, COMMISSION_PCT 
	, HIRE_DATE 
	FROM EMPLOYEES
 ORDER BY SALARY, 4 NULLS LAST;
 


SELECT DISTINCT DEPARTMENT_ID -- DISTINCT 중복 제거
	FROM EMPLOYEES;

-- GROUP BY
-- FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY
SELECT DEPARTMENT_ID
	, JOB_ID 
	, MIN(SALARY)
	, MAX(SALARY)
	, AVG(SALARY)
	, SUM(SALARY)
	, COUNT(SALARY)
	FROM EMPLOYEES
 GROUP BY DEPARTMENT_ID, JOB_ID -- 부서 아이디, JOB_ID 같은 애들끼리 묶기
 ORDER BY DEPARTMENT_ID; 
 

SELECT 	EXTRACT(YEAR FROM HIRE_DATE) AS 고용년 -- GROUP 묶은대로 SELECT 해야함
	, MIN(SALARY)
	, MAX(SALARY)
	, AVG(SALARY)
	, SUM(SALARY)
	, COUNT(SALARY)
	FROM EMPLOYEES
 GROUP BY EXTRACT(YEAR FROM HIRE_DATE) 
 HAVING COUNT(SALARY) > 1;
 -- HAVING은 그룹에 대한 WHERE

SELECT COMMISSION_PCT 
	, MIN(SALARY)
	, MAX(SALARY)
	, AVG(SALARY)
	, SUM(SALARY)
	, COUNT(SALARY)
	FROM EMPLOYEES
 WHERE COMMISSION_PCT IS NOT NULL 
 	AND SALARY >= 7000
 GROUP BY COMMISSION_PCT 
 HAVING AVG(SALARY) >= 9500
 ORDER BY 6;
 
 SELECT COMMISSION_PCT
 	, SALARY
 	FROM EMPLOYEES; 
 
/*
 * 1980 년대, 1990 년대, 2000 년대 별로 그룹을 묶어서 급여의 평균과 인원수를 구한다.
 */
 SELECT TRUNC(EXTRACT(YEAR FROM HIRE_DATE), -1)AS "고용년도"
 	, ROUND(AVG(SALARY), 2) AS 급여평균
 	, COUNT(*)
 	FROM EMPLOYEES
 GROUP BY TRUNC(EXTRACT(YEAR FROM HIRE_DATE), -1)
 ORDER BY 1;


 SELECT SUBSTR(TO_CHAR(EXTRACT(YEAR FROM HIRE_DATE)), 1, 3) || '0' AS "고용년도"
 	, ROUND(AVG(SALARY), 2) AS 급여평균
 	, COUNT(*)
 	FROM EMPLOYEES
 GROUP BY SUBSTR(TO_CHAR(EXTRACT(YEAR FROM HIRE_DATE)), 1, 3) || '0'
 ORDER BY 1;


 SELECT FLOOR(EXTRACT(YEAR FROM HIRE_DATE) / 10) * 10 AS "고용년도"
 	, ROUND(AVG(SALARY), 2) AS 급여평균
 	, COUNT(*)
 	FROM EMPLOYEES
 GROUP BY FLOOR(EXTRACT(YEAR FROM HIRE_DATE) / 10) * 10
 ORDER BY 1;

/*
 * 급여 집계를 위한 그룹을 다음과 같이 묶어서 총 인원수를 구한다.
 * 		2000 ~ 3500 	1그룹
 * 		3500 ~ 5000 	2그룹
 * 		5000 ~ 8000 	3그룹
 * 		8000 ~ 12000 	4그룹
 * 		12000 이상 		5그룹
 */
SELECT CASE WHEN SALARY >= 2000 AND SALARY < 3500 THEN '1그룹'
			WHEN SALARY >= 3500 AND SALARY < 5000 THEN '2그룹'
			WHEN SALARY >= 5000 AND SALARY < 8000 THEN '3그룹'
			WHEN SALARY >= 8000 AND SALARY < 12000 THEN '4그룹'
			WHEN SALARY >= 12000 THEN '5그룹'
		END AS 그룹
		, COUNT(*)
	FROM EMPLOYEES
 GROUP BY CASE  WHEN SALARY >= 2000 AND SALARY < 3500 THEN '1그룹'
				WHEN SALARY >= 3500 AND SALARY < 5000 THEN '2그룹'
				WHEN SALARY >= 5000 AND SALARY < 8000 THEN '3그룹'
				WHEN SALARY >= 8000 AND SALARY < 12000 THEN '4그룹'
				WHEN SALARY >= 12000 THEN '5그룹'
		END
ORDER BY 1;



-- ROLLUP 인자로 전달받은 그룹 중 가장 먼저 지정한 그룹별로 추가적 집계 결과 반환
-- 맨마지막에 전체 집계까지

SELECT DEPARTMENT_ID 
	, JOB_ID 
	, SUM(SALARY)
	, AVG(SALARY)
	, COUNT(*)
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID);

-- (3개로 묶고, 하위로 2개묶고, 하위로 1개 묶음 그리고 맨마지막에 전체 결과)
-- 1, 1+2, 1+2+3, 안묶은 것
SELECT DEPARTMENT_ID 
	, JOB_ID 
	, DECODE(NVL(COMMISSION_PCT, 0), 0, 'NO', 'YES')
	, SUM(SALARY)
	, AVG(SALARY)
	, COUNT(*)
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID, DECODE(NVL(COMMISSION_PCT, 0),0, 'NO', 'YES'));


-- CUBE 인자로 지정된 그룹들로 가능한 모든 조합 별로 집계한 결과 반환
-- NULL부터 나옴
-- JOB으로 집계 & DEPAMENT로 집계까지 
SELECT DEPARTMENT_ID 
	, JOB_ID 
	, SUM(SALARY)
	, AVG(SALARY)
	, COUNT(*)
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY CUBE(DEPARTMENT_ID, JOB_ID)
 ORDER BY DEPARTMENT_ID , JOB_ID NULLS LAST;
 

-- 1, 2, 3, 1+2, 1+3, 2+3, 1+2+3, 안묶은 것 까지 출력
SELECT DEPARTMENT_ID 
	, JOB_ID 
	, DECODE(NVL(COMMISSION_PCT, 0), 0, 'NO', 'YES')
	, SUM(SALARY)
	, AVG(SALARY)
	, COUNT(*)
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY CUBE(DEPARTMENT_ID, JOB_ID, DECODE(NVL(COMMISSION_PCT, 0),0, 'NO', 'YES'))
 ORDER BY DEPARTMENT_ID , JOB_ID NULLS LAST;