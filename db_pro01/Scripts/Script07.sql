-- ORDER BY는 마지막에 실행
SELECT EMPLOYEE_ID 
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, SALARY
	, COMMISSION_PCT 
	, HIRE_DATE 
	FROM EMPLOYEES
 ORDER BY SALARY, NAME DESC; -- 급여 내림차순, 급여동일하면 이름 오름차순 
-- 별칭, 컬럼순서, 컬럼명 지정 가능
-- 기본은 오름차순(DESC 붙이면 내림차순)

 
SELECT EMPLOYEE_ID 
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, SALARY
	, COMMISSION_PCT 
	, HIRE_DATE 
	FROM EMPLOYEES
 ORDER BY NAME DESC;
 
-- NULLS FIRST : NULL 데이터 먼저 보이게 / NULLS LAST : NULL 맨 뒤로
SELECT EMPLOYEE_ID 
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, SALARY
	, COMMISSION_PCT 
	, HIRE_DATE 
	FROM EMPLOYEES
 ORDER BY 4 NULLS FIRST;
 
SELECT EMPLOYEE_ID 
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, SALARY
	, COMMISSION_PCT 
	, HIRE_DATE 
	FROM EMPLOYEES
 ORDER BY SALARY, 4 NULLS LAST;
 


SELECT DISTINCT DEPARTMENT_ID -- DISTINCT 중복 제거
	FROM EMPLOYEES;

-- GROUP BY
-- FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY
SELECT DEPARTMENT_ID
	, JOB_ID 
	, MIN(SALARY)
	, MAX(SALARY)
	, AVG(SALARY)
	, SUM(SALARY)
	, COUNT(SALARY)
	FROM EMPLOYEES
 GROUP BY DEPARTMENT_ID, JOB_ID -- 부서 아이디, JOB_ID 같은 애들끼리 묶기
 ORDER BY DEPARTMENT_ID; 
 

SELECT 	EXTRACT(YEAR FROM HIRE_DATE) AS 고용년 -- GROUP 묶은대로 SELECT 해야함
	, MIN(SALARY)
	, MAX(SALARY)
	, AVG(SALARY)
	, SUM(SALARY)
	, COUNT(SALARY)
	FROM EMPLOYEES
 GROUP BY EXTRACT(YEAR FROM HIRE_DATE) 
 HAVING COUNT(SALARY) > 1;
 -- HAVING은 그룹에 대한 WHERE

SELECT COMMISSION_PCT 
	, MIN(SALARY)
	, MAX(SALARY)
	, AVG(SALARY)
	, SUM(SALARY)
	, COUNT(SALARY)
	FROM EMPLOYEES
 WHERE COMMISSION_PCT IS NOT NULL 
 	AND SALARY >= 7000
 GROUP BY COMMISSION_PCT 
 HAVING AVG(SALARY) >= 9500
 ORDER BY 6;
 
 SELECT COMMISSION_PCT
 	, SALARY
 	FROM EMPLOYEES; 
 
/*
 * 1980 년대, 1990 년대, 2000 년대 별로 그룹을 묶어서 급여의 평균과 인원수를 구한다.
 */
 SELECT TRUNC(EXTRACT(YEAR FROM HIRE_DATE), -1)AS "고용년도"
 	, ROUND(AVG(SALARY), 2) AS 급여평균
 	, COUNT(*)
 	FROM EMPLOYEES
 GROUP BY TRUNC(EXTRACT(YEAR FROM HIRE_DATE), -1)
 ORDER BY 1;


 SELECT SUBSTR(TO_CHAR(EXTRACT(YEAR FROM HIRE_DATE)), 1, 3) || '0' AS "고용년도"
 	, ROUND(AVG(SALARY), 2) AS 급여평균
 	, COUNT(*)
 	FROM EMPLOYEES
 GROUP BY SUBSTR(TO_CHAR(EXTRACT(YEAR FROM HIRE_DATE)), 1, 3) || '0'
 ORDER BY 1;


 SELECT FLOOR(EXTRACT(YEAR FROM HIRE_DATE) / 10) * 10 AS "고용년도"
 	, ROUND(AVG(SALARY), 2) AS 급여평균
 	, COUNT(*)
 	FROM EMPLOYEES
 GROUP BY FLOOR(EXTRACT(YEAR FROM HIRE_DATE) / 10) * 10
 ORDER BY 1;

/*
 * 급여 집계를 위한 그룹을 다음과 같이 묶어서 총 인원수를 구한다.
 * 		2000 ~ 3500 	1그룹
 * 		3500 ~ 5000 	2그룹
 * 		5000 ~ 8000 	3그룹
 * 		8000 ~ 12000 	4그룹
 * 		12000 이상 		5그룹
 */
SELECT CASE WHEN SALARY >= 2000 AND SALARY < 3500 THEN '1그룹'
			WHEN SALARY >= 3500 AND SALARY < 5000 THEN '2그룹'
			WHEN SALARY >= 5000 AND SALARY < 8000 THEN '3그룹'
			WHEN SALARY >= 8000 AND SALARY < 12000 THEN '4그룹'
			WHEN SALARY >= 12000 THEN '5그룹'
		END AS 그룹
		, COUNT(*)
	FROM EMPLOYEES
 GROUP BY CASE  WHEN SALARY >= 2000 AND SALARY < 3500 THEN '1그룹'
				WHEN SALARY >= 3500 AND SALARY < 5000 THEN '2그룹'
				WHEN SALARY >= 5000 AND SALARY < 8000 THEN '3그룹'
				WHEN SALARY >= 8000 AND SALARY < 12000 THEN '4그룹'
				WHEN SALARY >= 12000 THEN '5그룹'
		END
ORDER BY 1;



-- ROLLUP 인자로 전달받은 그룹 중 가장 먼저 지정한 그룹별로 추가적 집계 결과 반환
-- 맨마지막에 전체 집계까지

SELECT DEPARTMENT_ID 
	, JOB_ID 
	, SUM(SALARY)
	, AVG(SALARY)
	, COUNT(*)
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID);

-- (3개로 묶고, 하위로 2개묶고, 하위로 1개 묶음 그리고 맨마지막에 전체 결과)
-- 1, 1+2, 1+2+3, 안묶은 것
SELECT DEPARTMENT_ID 
	, JOB_ID 
	, DECODE(NVL(COMMISSION_PCT, 0), 0, 'NO', 'YES')
	, SUM(SALARY)
	, AVG(SALARY)
	, COUNT(*)
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID, DECODE(NVL(COMMISSION_PCT, 0),0, 'NO', 'YES'));


-- CUBE 인자로 지정된 그룹들로 가능한 모든 조합 별로 집계한 결과 반환
-- NULL부터 나옴
-- JOB으로 집계 & DEPAMENT로 집계까지 
SELECT DEPARTMENT_ID 
	, JOB_ID 
	, SUM(SALARY)
	, AVG(SALARY)
	, COUNT(*)
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY CUBE(DEPARTMENT_ID, JOB_ID)
 ORDER BY DEPARTMENT_ID , JOB_ID NULLS LAST;
 

-- 1, 2, 3, 1+2, 1+3, 2+3, 1+2+3, 안묶은 것 까지 출력
SELECT DEPARTMENT_ID 
	, JOB_ID 
	, DECODE(NVL(COMMISSION_PCT, 0), 0, 'NO', 'YES')
	, SUM(SALARY)
	, AVG(SALARY)
	, COUNT(*)
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY CUBE(DEPARTMENT_ID, JOB_ID, DECODE(NVL(COMMISSION_PCT, 0),0, 'NO', 'YES'))
 ORDER BY DEPARTMENT_ID , JOB_ID NULLS LAST;
 


/*
 * 부서, 고용년도 별 급여 통계(최고 급여, 최저 급여, 평균)을 구한다.
 * 		- ROLLUP, CUBE를 적용
 * 		- 부서가 NULL 인원은 제외한다.
 */


SELECT DEPARTMENT_ID AS 부서
	, EXTRACT (YEAR FROM HIRE_DATE) AS 고용년도
	, MAX(SALARY) AS 최대급여
	, MIN(SALARY) AS 최소급여
	, AVG(SALARY) AS 평균급여
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY ROLLUP (DEPARTMENT_ID, EXTRACT (YEAR FROM HIRE_DATE))
 ORDER BY DEPARTMENT_ID, 고용년도;
 
SELECT DEPARTMENT_ID AS 부서
	, EXTRACT (YEAR FROM HIRE_DATE) AS 고용년도
	, MAX(SALARY) AS 최대급여
	, MIN(SALARY) AS 최소급여
	, AVG(SALARY) AS 평균급여
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY CUBE(DEPARTMENT_ID, EXTRACT (YEAR FROM HIRE_DATE))
  ORDER BY DEPARTMENT_ID, 고용년도;
  
 
/*
 * - 모든 컬럼명은 한글로 별칭 부여, 조회
 * - FIRST_NAME과 LAST_NAME을 하나의 컬럼(이름)으로 만들어서 조회
 * - PHONE_NUMBER에서 사용한 구분자 . 은 - 로 변경하여 조회
 * - EMAIL 주소는 @example.com을 추가로 덧붙여 조회(소문자만)
 * - HIRE_DATE 는 YYYY년 MM월 DD일 형식으로 조회, 추가로 입사일부터 현재일까지의 근속일수 계산
 * - SALRAY는 원화 단위로 변환시켜 조회, COMMISSION_PCT있으면 이를 계산
 *   (100원 단위 절삭)
 * - 입사일을 기준으로 오름차순 정렬 조회
 */
 
 SELECT CONCAT(FIRST_NAME, ' ' || LAST_NAME) AS 이름
 	, REPLACE(PHONE_NUMBER , '.', '-') AS 전화번호
 	, LOWER(CONCAT(EMAIL, '@example.com')) AS 이메일
 	, TO_CHAR(HIRE_DATE, 'YYYY"년" MM"월" DD"일"') AS 입사일
 	, FLOOR(SYSDATE - HIRE_DATE) AS 근속일
 	, FLOOR(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) AS 근속월
 	, FLOOR(MONTHS_BETWEEN(SYSDATE, HIRE_DATE) /12) AS 근속년
 	, TO_CHAR(TRUNC(SALARY * (1 + NVL(COMMISSION_PCT, 0)) * 1260, -3), 'L999,999,999') AS 연봉
 FROM EMPLOYEES 
ORDER BY HIRE_DATE;

-- TO_DATE(SYSDATE) - TO_DATE(HIRE_DATE)  AS 근속일수 -- 모르겠음
/*
  * 전화번호 회선을 집계하기 위한 조회 쿼리
  * 	- 전화번호 회선은 515, 590, 650, 011, 603 별로 구분하여 얼마나 사용되고 있는지 조회
  * 	- 번호별 회선 수에 추가로 전체 회선수가 조회 될 수 있도록
  */
 
 SELECT NVL(SUBSTR(PHONE_NUMBER, 1, 3), '총합') AS 회선번호
 	,COUNT(*) AS 회선수
	FROM EMPLOYEES
 GROUP BY ROLLUP(SUBSTR(PHONE_NUMBER, 1, 3)); 
 
 /*
  * MANAGER_ID 는 해당 EMPLOYEE_ID 를 관리하는 관리자 정보가 연결되어있는 정보
  * 	- 한 명의 관리자가 얼마나 많은 직원을 관리하고 있는지 알 수 있도록 조회쿼리 작성
  * 	- MANAGER_ID 가 NULL 인 경우 제외하여 조회
  */
 

SELECT MANAGER_ID AS 관리자 
	, COUNT(*) AS 인원수
	FROM EMPLOYEES
 WHERE MANAGER_ID IS NOT NULL
 GROUP BY MANAGER_ID;
 
 
/*
 * GROUPING ->그룹으로 묶어서 나온 산출물이면 0
 * 					 안묶이면 1
 */
SELECT DEPARTMENT_ID AS 부서
	, EXTRACT (YEAR FROM HIRE_DATE) AS 고용년도
	, MAX(SALARY) AS 최대급여
	, MIN(SALARY) AS 최소급여
	, AVG(SALARY) AS 평균급여
	, CASE WHEN GROUPING(DEPARTMENT_ID) = 0 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 0 THEN '부서별/년도별'
		   WHEN GROUPING(DEPARTMENT_ID) = 0 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 1 THEN '부서별'	
		   WHEN GROUPING(DEPARTMENT_ID) = 1 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 0 THEN '년도별'	
		   WHEN GROUPING(DEPARTMENT_ID) = 1 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 1 THEN '전체(총)'
     	END AS 그룹구분
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY ROLLUP (DEPARTMENT_ID, EXTRACT (YEAR FROM HIRE_DATE))
 ORDER BY DEPARTMENT_ID, 고용년도;
 


SELECT DEPARTMENT_ID AS 부서
	, EXTRACT (YEAR FROM HIRE_DATE) AS 고용년도
	, MAX(SALARY) AS 최대급여
	, MIN(SALARY) AS 최소급여
	, AVG(SALARY) AS 평균급여
	, CASE WHEN GROUPING(DEPARTMENT_ID) = 0 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 0 THEN '부서별/년도별'
		   WHEN GROUPING(DEPARTMENT_ID) = 0 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 1 THEN '부서별'	
		   WHEN GROUPING(DEPARTMENT_ID) = 1 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 0 THEN '년도별'	
		   WHEN GROUPING(DEPARTMENT_ID) = 1 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 1 THEN '전체(총)'
     	END AS 그룹구분
	FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY CUBE(DEPARTMENT_ID, EXTRACT (YEAR FROM HIRE_DATE))
 ORDER BY DEPARTMENT_ID, 고용년도;