-- SET SERVEROUTPUT ON; 을 해야 출력이됨 (DBeaver에는 자동으로 켜져있음)

DECLARE
	VAR1 NUMBER;
	VAR2 VARCHAR2(30);
	VAR3 VARCHAR2(30);
BEGIN
	VAR1 := 100;
	VAR2 := 'Hello';
	VAR3 := &VAR3;  -- 사용자 입력받기
	
 DBMS_OUTPUT.PUT_LINE(VAR1);
 DBMS_OUTPUT.PUT_LINE(VAR2);
 DBMS_OUTPUT.PUT_LINE(VAR3);
END;

-- IF문 (ELSE 생략가능 / ELSIF 는 ELSE IF를 의미)
DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;
	IF(VAR1 > 10) THEN
		DBMS_OUTPUT.PUT_LINE('10보다 큰 값을 입력');
	ELSIF(VAR1 = 10) THEN
		DBMS_OUTPUT.PUT_LINE('10을 입력');
	ELSE
		DBMS_OUTPUT.PUT_LINE('10보다 작은 값 입력');
	END IF;
END;



DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;
	IF(MOD(VAR1, 2) = 0) THEN
		DBMS_OUTPUT.PUT_LINE('짝수 입니다.');
	ELSE
		DBMS_OUTPUT.PUT_LINE('홀수 입니다.');
	END IF;
END;

--반복문(LOOP....END LOOP)
-- LOOP만 사용하면 무한반복
DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;
	LOOP
		DBMS_OUTPUT.PUT_LINE(VAR1);
		IF(VAR1 = 0) THEN 
			EXIT;
		END IF;
		VAR1 := VAR1 - 1;
	END LOOP;
END;


-- 0..VAR1
DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;
	
	FOR I IN 0..VAR1 LOOP -- (0에서 VAR1까지)
		DBMS_OUTPUT.PUT_LINE(VAR1 || '/' || I);
	END LOOP;
END;

-- REVERSE
DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;
	
	FOR I IN REVERSE 0..VAR1 LOOP -- (VAR1에서 0까지)
		DBMS_OUTPUT.PUT_LINE(VAR1 || '/' || I);
	END LOOP;
END;



-- WHILE문 
DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;
	
	WHILE VAR1 > 0 LOOP
		DBMS_OUTPUT.PUT_LINE(VAR1);
		VAR1 := VAR1 - 1;
	END LOOP;
END;

-- INTO 는 변수 
DECLARE
	USER_INPUT NUMBER;
	EMP_NAME1 VARCHAR2(50);
	EMP_NAME2 VARCHAR2(50);
	EMP_ID NUMBER;
BEGIN
	SELECT EMPLOYEE_ID 
		 , FIRST_NAME 
		 , LAST_NAME
		INTO EMP_ID, EMP_NAME1, EMP_NAME2
		FROM EMPLOYEES
	   WHERE EMPLOYEE_ID = &USER_INPUT;
	  
	  DBMS_OUTPUT.PUT_LINE(EMP_ID);
	  DBMS_OUTPUT.PUT_LINE(EMP_NAME1);
	  DBMS_OUTPUT.PUT_LINE(EMP_NAME2);
END;


-- %TYPE을 이용해서 참조타입을 알아서 설정하게 할 수 있다.
DECLARE
	EMP_NAME1 EMPLOYEES.FIRST_NAME%TYPE;
	EMP_NAME2 EMPLOYEES.LAST_NAME%TYPE;
	EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE;
BEGIN
	FOR ID IN 100..199 LOOP
		SELECT EMPLOYEE_ID 
			 , FIRST_NAME 
			 , LAST_NAME
			INTO EMP_ID, EMP_NAME1, EMP_NAME2
			FROM EMPLOYEES
	   	WHERE EMPLOYEE_ID = ID;
	  
	  DBMS_OUTPUT.PUT_LINE(EMP_ID || ', ' || EMP_NAME1 || ', ' || EMP_NAME2);
	END LOOP;
END;



-- ROWTYPE 한 행에 대해서 데이터 타입으로 보겠다
-- (반복조회)
DECLARE
	ROW_DATA EMPLOYEES%ROWTYPE;
BEGIN
	FOR ID IN 100..199 LOOP
		SELECT *
			INTO ROW_DATA
			FROM EMPLOYEES
	   	WHERE EMPLOYEE_ID = ID;
	  
	  DBMS_OUTPUT.PUT_LINE(ROW_DATA.EMPLOYEE_ID || ', ' || 
	 ROW_DATA.FIRST_NAME || ', ' || ROW_DATA.LAST_NAME);
	END LOOP;
END;


-- 첫번째 줄-> 테이블타입(배열타입) 생성
-- IS TABLE OF 문은 배열에 저장할 데이터 타입 명시
-- INDEX BY 문은 INDEX로 사용할 타입 지정
-- 이 테이블타입을 사용할 변수 ENP_IDS를 생성
-- (한번조회)
DECLARE
	TYPE EMP_ID_TABLE_TYPE IS TABLE OF EMPLOYEES.EMPLOYEE_ID%TYPE
							  INDEX BY BINARY_INTEGER;
	TYPE EMP_NAME_TABLE_TYPE IS TABLE OF EMPLOYEES.FIRST_NAME%TYPE
	 						    INDEX BY BINARY_INTEGER;
	EMP_IDS    EMP_ID_TABLE_TYPE;
    EMP_NAMES  EMP_NAME_TABLE_TYPE;
	IDX        BINARY_INTEGER := 0;
BEGIN
	FOR R_DATA IN (SELECT EMPLOYEE_ID 
						, FIRST_NAME
			     FROM EMPLOYEES 
			    WHERE EMPLOYEE_ID BETWEEN 100 AND 199)	 LOOP
  		IDX := IDX + 1;
  		EMP_IDS(IDX) := R_DATA.EMPLOYEE_ID;
		EMP_NAMES(IDX) := R_DATA.FIRST_NAME;
  	 
	  -- DBMS_OUTPUT.PUT_LINE(EMP_IDS(IDX) || ' ' || EMP_NAMES(IDX));
	END LOOP;

	FOR I IN 1..EMP_IDS.COUNT LOOP		-- COUNT가 배열에 저장된 수를 세어줌
		DBMS_OUTPUT.PUT_LINE(EMP_IDS(I) || ' ' || EMP_NAMES(I));
	END LOOP;
END;


-- ROWTYPE 응용
DECLARE
	TYPE EMP_ROW_TABLE_TYPE IS TABLE OF EMPLOYEES%ROWTYPE
							  INDEX BY BINARY_INTEGER;
	EMP_ROWS EMP_ROW_TABLE_TYPE;
	IDX BINARY_INTEGER := 0;
BEGIN
	FOR R_DATA IN (SELECT *
			     FROM EMPLOYEES 
			    WHERE EMPLOYEE_ID BETWEEN 100 AND 199)	 LOOP
  		IDX := IDX + 1;
  		EMP_ROWS(IDX) := R_DATA;
	END LOOP;

	FOR I IN 1..EMP_ROWS.COUNT LOOP
		DBMS_OUTPUT.PUT_LINE(EMP_ROWS(I).EMPLOYEE_ID ||
						' ' || EMP_ROWS(I).FIRST_NAME);
	END LOOP;
END;





-- RECORD 1개행 N열
-- 테이블타입에는 한번에 한개의 컬럼(열)만 넣을 수 있음
-- JOIN쓸때 추천
DECLARE
	TYPE EMP_RECORD_TYPE IS RECORD (
		  ID          EMPLOYEES.EMPLOYEE_ID%TYPE
		, FIRST_NAME  EMPLOYEES.FIRST_NAME%TYPE
		, LAST_NAME   EMPLOYEES.LAST_NAME%TYPE
		, SALARY      EMPLOYEES.SALARY%TYPE
		, DEPART_ID   DEPARTMENTS.DEPARTMENT_ID%TYPE
		, DEPART_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE
	); 

	TYPE EMP_TABLE_TYPE IS TABLE OF EMP_RECORD_TYPE INDEX BY BINARY_INTEGER;

	EMP_TABLE EMP_TABLE_TYPE;
	IDX BINARY_INTEGER := 0;
BEGIN
	FOR D IN (SELECT E.EMPLOYEE_ID
				   , E.FIRST_NAME
				   , E.LAST_NAME
				   , E.SALARY
				   , D.DEPARTMENT_ID
				   , D.DEPARTMENT_NAME
				FROM EMPLOYEES E JOIN DEPARTMENTS D 
				  ON E.DEPARTMENT_ID  = D.DEPARTMENT_ID) LOOP 
			IDX := IDX + 1;
		 	EMP_TABLE(IDX) := D;
	  END LOOP;
	 
	 FOR REC IN 1..EMP_TABLE.COUNT LOOP
		 DBMS_OUTPUT.PUT_LINE('?' || EMP_TABLE(REC).ID);	
	 END LOOP;
END;
